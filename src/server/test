pub mod request_stream {
    use std::io::{self, Read};

    const BUFFER_SIZE: usize = 4096;
    const MAX_REQUEST_SIZE: usize = 10 * 1024 * 1024;

    #[derive(Debug, Clone)]
    pub struct RequestData {
        // Raw data containing both headers and body
        pub data: Vec<u8>,
        // Optional positions for internal processing
        headers_end: usize,
    }

    impl RequestData {
        // Helper methods to access parts if needed
        pub fn get_headers(&self) -> &[u8] {
            &self.data[..self.headers_end]
        }

        pub fn get_body(&self) -> &[u8] {
            &self.data[self.headers_end..]
        }
    }

    #[derive(Debug)]
    enum ReaderType {
        Unknown,
        Standard { content_length: usize },
        Chunked,
    }

    #[derive(Debug, Clone)]
    pub enum RequestState {
        AwaitingHeaders,
        ProcessingBody { 
            accumulated_data: Vec<u8>,
            headers_end: usize,
        },
        Complete(RequestData),
        EndOfStream,
    }

    pub trait RequestStream {
        fn read_next(&mut self) -> io::Result<RequestState>;
        fn write(&mut self, buf: &[u8]) -> io::Result<()>;
        fn flush(&mut self) -> io::Result<()>;
        fn reset(&mut self);
        fn is_complete(&self) -> bool;
    }

    pub mod unifiedReader {
        use super::*;
        use std::io::{self, Read, Write, ErrorKind};

        pub struct UnifiedReader<S: Read + Write> {
            stream: S,
            buffer: Vec<u8>,
            state: RequestState,
            reader_type: ReaderType,
            temp_chunk_headers: Option<Vec<u8>>,
            current_chunk_size: Option<usize>,
        }

        impl<S: Read + Write> UnifiedReader<S> {
            pub fn new(stream: S) -> Self {
                UnifiedReader {
                    stream,
                    buffer: Vec::new(),
                    state: RequestState::AwaitingHeaders,
                    reader_type: ReaderType::Unknown,
                    temp_chunk_headers: None,
                    current_chunk_size: None,
                }
            }

            fn determine_reader_type(data: &[u8], headers_end: usize) -> ReaderType {
                if let Ok(headers_str) = String::from_utf8(data[..headers_end].to_vec()) {
                    if headers_str.lines().any(|line| line.to_lowercase().contains("transfer-encoding: chunked")) {
                        return ReaderType::Chunked;
                    }

                    if let Some(content_length) = headers_str.lines()
                        .find(|line| line.to_lowercase().starts_with("content-length:"))
                        .and_then(|line| line.split(':').nth(1))
                        .and_then(|len| len.trim().parse::<usize>().ok()) {
                        return ReaderType::Standard { content_length };
                    }
                }
                ReaderType::Standard { content_length: 0 }
            }

            // fn process_standard_body(&mut self, accumulated_data: Vec<u8>, headers_end: usize, content_length: usize) -> io::Result<RequestState> {
            //     let total_expected = headers_end + content_length;
                
            //     if accumulated_data.len() >= total_expected {
            //         // We have all the data we need
            //         let request_data = RequestData {
            //             data: accumulated_data[..total_expected].to_vec(),
            //             headers_end,
            //         };
            //         self.buffer = accumulated_data[total_expected..].to_vec();
            //         self.state = RequestState::Complete(request_data);
            //         return Ok(self.state.clone());
            //     } 
            //         // Still need more data
            //         self.state = RequestState::ProcessingBody { 
            //             accumulated_data,
            //             headers_end 
            //         };

            //         self.read_next()
            // }

            fn process_standard_body(
                &mut self,
                mut accumulated_data: Vec<u8>,
                headers_end: usize,
                content_length: usize,
            ) -> io::Result<RequestState> {
                let total_expected = headers_end + content_length;
            
                while accumulated_data.len() < total_expected {
                    let mut temp_buffer = [0u8; BUFFER_SIZE];
                    let bytes_read = self.stream.read(&mut temp_buffer)?;
                    if bytes_read == 0 {
                        // End of stream
                        return Ok(RequestState::EndOfStream);
                    }
                    accumulated_data.extend_from_slice(&temp_buffer[..bytes_read]);
                }
            
                // We have all the data we need
                let request_data = RequestData {
                    data: accumulated_data[..total_expected].to_vec(),
                    headers_end,
                };
                self.buffer = accumulated_data[total_expected..].to_vec();
                self.state = RequestState::Complete(request_data);
            
                Ok(self.state.clone())
            }
            

            fn process_chunked_body(
                &mut self,
                mut accumulated_data: Vec<u8>,
                headers_end: usize,
            ) -> io::Result<RequestState> {
                loop {
                    // Read chunk size if necessary
                    if self.current_chunk_size.is_none() {
                        if let Some(line_end) = find_line_end(&self.buffer) {
                            let size_line = &self.buffer[..line_end - 2];
                            if let Some(size) = parse_chunk_size(size_line) {
                                if size == 0 {
                                    // Final chunk - complete request
                                    self.state = RequestState::Complete(RequestData {
                                        data: accumulated_data,
                                        headers_end,
                                    });
                                    return Ok(self.state.clone());
                                }
                                self.current_chunk_size = Some(size);
                                self.buffer = self.buffer[line_end..].to_vec();
                            }
                        }
                    }
            
                    if let Some(chunk_size) = self.current_chunk_size {
                        if self.buffer.len() >= chunk_size + 2 {
                            // Append chunk data to accumulated data
                            accumulated_data.extend_from_slice(&self.buffer[..chunk_size]);
                            self.buffer = self.buffer[chunk_size + 2..].to_vec();
                            self.current_chunk_size = None;
                            
                        } else {
                            let mut temp_buffer = [0u8; BUFFER_SIZE];
                            let bytes_read = self.stream.read(&mut temp_buffer)?;
                            if bytes_read == 0 {
                                return Ok(RequestState::EndOfStream);
                            }
                            self.buffer.extend_from_slice(&temp_buffer[..bytes_read]);
                        }
                    }
                }
            }
            

            // fn process_chunked_body(&mut self, mut accumulated_data: Vec<u8>, headers_end: usize) -> io::Result<RequestState> {

            //     if self.current_chunk_size.is_none() {
            //         // Read chunk size
            //         if let Some(line_end) = find_line_end(&self.buffer) {
            //             let size_line = &self.buffer[..line_end - 2];
            //             if let Some(size) = parse_chunk_size(size_line) {
            //                 if size == 0 {
            //                     println!("---------------------------FINAL");
            //                     // Final chunk - complete request
            //                     self.state = RequestState::Complete(RequestData {
            //                         data: accumulated_data,
            //                         headers_end,
            //                     });
            //                     return Ok(self.state.clone());
            //                 }
            //                 println!("* * * * * * * * *  *  * ** * *CURRENT: {}", size);
            //                 self.current_chunk_size = Some(size);
            //                 self.buffer = self.buffer[line_end..].to_vec();
            //             }
            //         }
            //     }

            //     if let Some(chunk_size) = self.current_chunk_size {
            //         if self.buffer.len() >= chunk_size + 2 {
            //             // Append chunk data to accumulated data
            //             accumulated_data.extend_from_slice(&self.buffer[..chunk_size]);
            //             self.buffer = self.buffer[chunk_size + 2..].to_vec();
            //             self.current_chunk_size = None;

            //             self.state = RequestState::Complete(RequestData{
            //                 data: accumulated_data,
            //                 headers_end
            //             })
            //         }
            //     }

            //     self.read_next()
            // }
        }

        impl<S: Read + Write> RequestStream for UnifiedReader<S> {
            
            fn read_next(&mut self) -> io::Result<RequestState> {
                
                let mut temp_buffer = [0u8; BUFFER_SIZE];
                    match self.state.clone() {

                        RequestState::AwaitingHeaders => {
                            match self.stream.read(&mut temp_buffer)? {
                                0 => Ok(RequestState::EndOfStream),
                                n => {
                                    self.buffer.extend_from_slice(&temp_buffer[..n]);
                                    if let Some(headers_end) = find_headers_end(&self.buffer) {
                                        let accumulated_data = self.buffer.clone();
                                        self.reader_type = Self::determine_reader_type(&accumulated_data, headers_end);
                                        self.buffer = self.buffer[headers_end..].to_vec();
                                        self.state = RequestState::ProcessingBody { 
                                            accumulated_data,
                                            headers_end,
                                        };
                                        self.read_next()
                                    } else {
                                        Ok(RequestState::AwaitingHeaders)
                                    }
                                }
                            }
                        }

                        RequestState::ProcessingBody { accumulated_data, headers_end } => {
                            match self.reader_type {
                                ReaderType::Unknown => Ok(RequestState::EndOfStream),
                            ReaderType::Standard { content_length} => {
                                return self.process_standard_body(accumulated_data, headers_end, content_length);
                            },
                            ReaderType::Chunked => {
                                return self.process_chunked_body(accumulated_data, headers_end);
                            }
                            }
                        }

            
                        RequestState::Complete(_) => {
                            return Ok(self.state.clone());
                        }
            
                        RequestState::EndOfStream => {
                            return Ok(RequestState::EndOfStream);
                        }
                    
                }
            }
            
            

            // fn read_next(&mut self) -> io::Result<RequestState> {
            //     let mut temp_buffer = [0u8; BUFFER_SIZE];
            //     match &self.state {

                    // RequestState::AwaitingHeaders => {
                    //     match self.stream.read(&mut temp_buffer)? {
                    //         0 => Ok(RequestState::EndOfStream),
                    //         n => {
                    //             println!("Get Header  ; ; ; ; ; ; ; ; ;  ; / /  : : : : : :   :  : :: ");
                    //             self.buffer.extend_from_slice(&temp_buffer[..n]);
                    //             if let Some(headers_end) = find_headers_end(&self.buffer) {
                    //                 let accumulated_data = self.buffer.clone();
                    //                 self.reader_type = Self::determine_reader_type(&accumulated_data, headers_end);
                    //                 self.buffer = self.buffer[headers_end..].to_vec();
                    //                 self.state = RequestState::ProcessingBody { 
                    //                     accumulated_data,
                    //                     headers_end,
                    //                 };
                    //                 self.read_next()
                    //             } else {
                    //                 println!("JE PART PAS, JE SUIS COINCE / : : ::  : : : : : : :");
                    //                 Ok(RequestState::AwaitingHeaders)
                    //             }
                    //         }
                    //     }
                    // }
            //         RequestState::ProcessingBody { accumulated_data, headers_end } => {
            //             match self.reader_type {
            //                 ReaderType::Unknown => Ok(RequestState::EndOfStream),
            //                 ReaderType::Standard { content_length } => {
            //                     match self.stream.read(&mut temp_buffer) {
            //                         Ok(0) => {
            //                             Ok(RequestState::EndOfStream)
            //                         },
            //                         Ok(n) => {
            //                             self.buffer.extend_from_slice(&temp_buffer[..n]);
            //                             let mut new_accumulated = accumulated_data.clone();
            //                             new_accumulated.extend_from_slice(&self.buffer);
            //                             self.buffer.clear();
            //                             self.process_standard_body(new_accumulated, *headers_end, content_length)

            //                         },
            //                         Err(e) if e.kind() == ErrorKind::WouldBlock => {
            //                             if content_length == 0 {
            //                                 self.state = RequestState::Complete(RequestData{ data: accumulated_data.clone(), headers_end: *headers_end });
            //                                 return Ok(self.state.clone());
            //                             }
                                        
            //                             self.state = RequestState::ProcessingBody { accumulated_data: accumulated_data.clone(), headers_end: *headers_end };
            //                             self.read_next()
            //                         },
            //                         Err(e) => Err(e)
            //                     }
            //                 }
            //                 ReaderType::Chunked => {
            //                     match self.stream.read(&mut temp_buffer)? {
            //                         0 => Ok(RequestState::EndOfStream),
            //                         n => {
            //                             self.buffer.extend_from_slice(&temp_buffer[..n]);
            //                             self.process_chunked_body(accumulated_data.clone(), *headers_end)
            //                         }
            //                     }
            //                 }
            //             }
            //         }
            //         RequestState::Complete(_) | RequestState::EndOfStream => {
            //             Ok(self.state.clone())
            //         }
            //     }
            // }

            fn write(&mut self, buf: &[u8]) -> io::Result<()> {
                self.stream.write_all(buf)
            }
        
            fn flush(&mut self) -> io::Result<()> {
                self.stream.flush()
            }

            fn reset(&mut self) {
                self.buffer.clear();
                self.reader_type = ReaderType::Unknown;
                self.state = RequestState::AwaitingHeaders;
                self.current_chunk_size = None;
            }
        
            fn is_complete(&self) -> bool {
                matches!(self.state, RequestState::Complete(_))
            }
        }
    }

    fn find_headers_end(data: &[u8]) -> Option<usize> {
        data.windows(4)
            .position(|window| window == b"\r\n\r\n")
            .map(|pos| pos + 4)
    }

    fn parse_chunk_size(line: &[u8]) -> Option<usize> {
        if let Ok(size_str) = String::from_utf8(line.to_vec()) {
            return usize::from_str_radix(&size_str.trim(), 16).ok();
        }
        None
    }

    fn find_line_end(data: &[u8]) -> Option<usize> {
        data.windows(2)
            .position(|window| window == b"\r\n")
            .map(|pos| pos + 2)
    }

    pub use unifiedReader::UnifiedReader;
}